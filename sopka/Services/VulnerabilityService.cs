using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Data.SqlClient;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading.Tasks;
using Dapper;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Http.Internal;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using sopka.Models;
using sopka.Models.ContextModels;
using sopka.Models.DTO;
using sopka.Models.Filters;
using sopka.Models.Vulnerabilities;

namespace sopka.Services
{
    public class VulnerabilityService
    {
        private readonly SopkaDbContext _context;
        private readonly string _connectionString;
        private readonly FileService _fileService;
        private readonly VulnerabilityOptions _options;

        public VulnerabilityService(SopkaDbContext context, IOptions<VulnerabilityOptions> options, FileService fileService)
        {
            _context = context;
            _connectionString = _context.Database.GetDbConnection().ConnectionString;;
            _fileService = fileService;
            _options = options.Value;
        }

        public async Task<Vulnerability> Get(int id)
        {
            return await _context
                .Vulnerabilities
                .AsNoTracking()
                .FirstOrDefaultAsync(x => x.Id == id);
        }

        public async Task<List<VulnerabilityFolder>> Folders()
        {
            return await _context
                    .VulnerabilityFolders
                    .AsNoTracking()
                    .ToListAsync();
        }

        public async Task<List<Vulnerability>> GetVulnerabilities(VulnerabilitiesFilter filter)
        {
            var query = _context.Vulnerabilities.AsNoTracking();

            if (filter.Countries != null && filter.Countries.Any())
                query = query.Where(x => filter.Countries.Contains(x.Country));

            if (filter.Regulations != null && filter.Regulations.Any())
                query = query.Where(x => filter.Regulations.Contains(x.Regulations));

            if (filter.Manufacturers != null && filter.Manufacturers.Any())
                query = query.Where(x => filter.Manufacturers.Contains(x.Manufacturer));

            if (filter.Research != null && filter.Research.Any())
                query = query.Where(x => filter.Research.Contains(x.Research));

            if (filter.Incidents != null && filter.Incidents.Any())
                query = query.Where(x => filter.Incidents.Contains(x.Incidents));

            if (filter.Resources != null && filter.Resources.Any())
                query = query.Where(x => filter.Resources.Contains(x.Resources));

            if (filter.StatusId != null)
                query = query.Where(x => x.StatusType == (Vulnerability.Status) filter.StatusId);

            if (filter.UseCreateDate && string.IsNullOrEmpty(filter.CreateDateFrom) == false && string.IsNullOrEmpty(filter.CreateDateTo) == false)
            {
                var format = "dd.MM.yyyy HH:mm";
                if (DateTimeOffset.TryParseExact(filter.CreateDateFrom,
                    new string[] { format },
                    CultureInfo.InvariantCulture.DateTimeFormat,
                    DateTimeStyles.AllowWhiteSpaces,
                    out var from)
                    &&
                    DateTimeOffset.TryParseExact(filter.CreateDateTo,
                        new string[] { format },
                        CultureInfo.InvariantCulture.DateTimeFormat,
                        DateTimeStyles.AllowWhiteSpaces,
                        out var to))
                {
                    query = query.Where(x => x.CreateDate >= from && x.CreateDate <= to);
                }
            }

            var items = await query.ToListAsync();

            //return items
            //    .Select(x => new VulnerabilityListItem()
            //    {
            //        Id = x.Id,
            //        IdFolder = x.IdFolder,
            //        Title = x.Title
            //    })
            //    .ToList();
            return items;
        }

        public async Task Import(Stream body)
        {
            var docs = await Parse(body);
            await Process(docs);
        }

        private async Task<List<VulnerabilityInfo>> Parse(Stream stream)
        {
            var docs = new List<VulnerabilityInfo>();
            using (var requestBody = stream)
            {
                using (var streamReader = new StreamReader(requestBody))
                {
                    using (JsonTextReader reader = new JsonTextReader(streamReader))
                    {
                        while (await reader.ReadAsync())
                        {
                            if (reader.TokenType != JsonToken.StartObject)
                            {
                                continue;
                            }

                            var jObject = JObject.Load(reader);
                            var entity = new VulnerabilityInfo();

                            #region Поля объекта
                            ParseField(jObject, nameof(VulnerabilityInfo.Folder), token => entity.Folder = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.FolderPath), token => entity.FolderPath = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Title), token => entity.Title = token.Value<string>());
                            ParseFile (jObject, nameof(VulnerabilityInfo.OriginalFile), file => entity.OriginalFile = file);
                            ParseFile (jObject, nameof(VulnerabilityInfo.TranslationFile), file => entity.TranslationFile = file);
                            ParseField(jObject, nameof(VulnerabilityInfo.CreateDate), token => entity.CreateDate = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Country), token => entity.Country = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Manufacturer), token => entity.Manufacturer = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Regulations), token => entity.Regulations = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Research), token => entity.Research = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Incidents), token => entity.Incidents = token.Value<string>());
                            ParseField(jObject, nameof(VulnerabilityInfo.Resources), token => entity.Resources = token.Value<string>());

                            #endregion

                            docs.Add(entity);
                        }
                    }
                }
            }
            return docs;
        }

        private void ParseField(JObject jObject, string destFieldName, Action<JToken> action)
        {
            var srcFieldName = GetFieldName(destFieldName);
            var jToken = jObject[srcFieldName];
            if (jToken != null)
            {
                action(jToken);
            }
        }

        private string GetFieldName(string logFieldName)
        {
            return _options.FieldMapping.ContainsKey(logFieldName)
                ? _options.FieldMapping[logFieldName]
                : logFieldName;
        }

        private void ParseFile(JObject jObject, string fieldName, Action<JsonFile> action)
        {
            var srcFieldName = GetFieldName(fieldName);

            if (jObject[srcFieldName] is JObject jToken)
            {
                var result = new JsonFile();
                ParseField(jToken, nameof(JsonFile.Name), token => result.Name = token.Value<string>());
                ParseField(jToken, nameof(JsonFile.FileName), token => result.FileName = token.Value<string>());
                ParseField(jToken, nameof(JsonFile.ContentEncoding), token => result.ContentEncoding = token.Value<string>());
                ParseField(jToken, nameof(JsonFile.ContentType), token => result.ContentType = token.Value<string>());
                ParseField(jToken, nameof(JsonFile.FileContents), token => result.FileContents = token.Value<string>());
                action(result);
            }
        }



        public async Task<List<DictionaryDataItem<string, string>>> Dictionaries()
        {
            using (var conn = new SqlConnection(_connectionString))
            {
                conn.Open();
                var items = (await conn.QueryAsync<DictionaryDataItem<string, string>>($"execute dbo.VulnerabilitiesDictionaries")).ToList();
                return items;
            }
        }

        private async Task<List<Vulnerability>> Process(List<VulnerabilityInfo> vulnerabilities)
        {
            var existingFolders = await _context.VulnerabilityFolders.AsNoTracking().ToListAsync();
            var result = new List<Vulnerability>();

            foreach (var info in vulnerabilities)
            {
                var entity = new Vulnerability()
                {
                    Id = 0,
                    Title = info.Title,
                    Country = info.Country,
                    Incidents = info.Incidents,
                    Manufacturer = info.Manufacturer,
                    Regulations = info.Regulations,
                    Research = info.Research,
                    Resources = info.Resources,
                    IdFolder = await ProcessFolder(info.Folder, info.FolderPath, existingFolders)
                };
                
                if (DateTimeOffset.TryParseExact(info.CreateDate, 
                    new string[] {_options.DateTimeFormat }, 
                    CultureInfo.InvariantCulture.DateTimeFormat,
                    DateTimeStyles.AllowWhiteSpaces,
                    out var createDate))
                {
                    entity.CreateDate = createDate;
                }
                else
                {
                    entity.CreateDate = DateTimeOffset.Now;
                }

                _context.Vulnerabilities.Add(entity);
                await _context.SaveChangesAsync();
                var files = new List<IFormFile>()
                {
                    ProcessFileData(info.OriginalFile),
                    ProcessFileData(info.TranslationFile)
                };
                var filesResult = await _fileService.Store(entity.Id, typeof(Vulnerability).Name.ToLower(), files);
                if (filesResult != null)
                {
                    if (info.OriginalFile != null && filesResult.Count > 0)
                    {
                        entity.OriginalFileId = filesResult[0].Id;
                    }

                    if (info.TranslationFile != null && filesResult.Count > 1)
                    {
                        entity.TranslationFileId = filesResult[1].Id;
                    }
                }

                result.Add(entity);
            }

            await _context.SaveChangesAsync();
            return result;
        }

        
        private IFormFile ProcessFileData(JsonFile data)
        {
            if (data == null) return null;
            if(data.ContentEncoding.Equals("base64", StringComparison.InvariantCultureIgnoreCase) == false)
                throw new ArgumentException("Wrong content encoding. Expected Base64.");

            var imageDataByteArray = Convert.FromBase64String(data.FileContents);

            return new FormFile(new MemoryStream(imageDataByteArray) {Position = 0},
                0,
                imageDataByteArray.Length,
                data.Name,
                data.FileName)
            {
                Headers = new HeaderDictionary(),
                ContentType = data.ContentType
            };
        }

        private async Task<int> ProcessFolder(string folderName, string folderPath, List<VulnerabilityFolder> existingFolders)
        {
            var path = folderPath.Split(_options.FolderSeparator);
            int? parentId = null;
            foreach (var folder in path)
            {
                var normalizedName = folder.Trim();
                var existingFolder = existingFolders.FirstOrDefault(x => x.Title == normalizedName && x.IdParent == parentId);
                if (existingFolder == null)
                {
                    var entity = new VulnerabilityFolder()
                    {
                        Title = normalizedName,
                        IdParent = parentId
                    };
                    _context.VulnerabilityFolders.Add(entity);
                    await _context.SaveChangesAsync();
                    parentId = entity.Id;
                }
                else
                {
                    parentId = existingFolder.Id;
                }
            }

            if (path.Last().Trim() == folderName.Trim())
            {
                return parentId ?? 0;
            }
        
            var currentFolder = new VulnerabilityFolder()
            {
                Title = folderName.Trim(),
                IdParent = parentId
            };
            _context.VulnerabilityFolders.Add(currentFolder);
            await _context.SaveChangesAsync();
            return currentFolder.Id;
        }

        /// <summary>
        /// Сохранение комментария
        /// </summary>
        /// <param name="vulnerabilityId"></param>
        /// <param name="comment"></param>
        /// <param name="userId"></param>
        /// <returns></returns>
        public async Task<int> StoreComment(int vulnerabilityId, string comment, string userId)
        {
            if (string.IsNullOrEmpty(comment)) throw new ArgumentNullException(nameof(comment), "Отсутствует текст комментария");
            if (string.IsNullOrEmpty(userId)) throw new ArgumentNullException(nameof(userId), "Пользователь не задан");

            var entity = new VulnerabilityComment()
            {
                Id = 0,
                VulnerabilityId = vulnerabilityId,
                Comment = comment,
                CreateDate = DateTimeOffset.Now,
                UserId = userId,
            };

            _context.Add(entity);
            await _context.SaveChangesAsync();

            return entity.Id;
        }

        /// <summary>
        /// Получение списка комментариев к уязвимости
        /// </summary>
        /// <param name="vulnerabilityId"></param>
        /// <returns></returns>
        public async Task<List<VulnerabilityComment>> GetComments(int vulnerabilityId)
        {
            return await _context.VulnerabilityComments
                .AsNoTracking()
                .OrderByDescending(x => x.CreateDate)
                .Where(x => x.VulnerabilityId == vulnerabilityId)
                .ToListAsync();
        }

        public async Task<int> SetStatus(int vulnerabilityId, int statusId, AppUser user)
        {
            if (user == null) throw new ArgumentNullException(nameof(user), "Пользователь не задан");
            var userEntity = _context.Users.Include(x => x.UserRoles).AsNoTracking()
                .FirstOrDefaultAsync(x => x.Id == user.Id);
            if(userEntity == null) throw new ArgumentException("Пользователь не найден", nameof(user));
            if (user.UserRoles.Any(x => x.Role.Name == "Администратор"))
                throw new Exception("Администратор не может менять статус уязвимости");

            var entity = await _context.Vulnerabilities.FirstOrDefaultAsync(x => x.Id == vulnerabilityId);
            if(entity == null) throw new ArgumentException("Уязвимость не найдена", nameof(vulnerabilityId));

            var statusType = (Vulnerability.Status) statusId;
            entity.StatusType = statusType;
            await _context.SaveChangesAsync();
            return entity.Id;
        }

        public async Task<List<Vulnerability>> GetFolderContents(int folderId)
        {
            return await _context.Vulnerabilities
                .AsNoTracking()
                .OrderByDescending(x => x.CreateDate)
                .Where(x => x.IdFolder == folderId)
                .ToListAsync();
        }
    }
}
